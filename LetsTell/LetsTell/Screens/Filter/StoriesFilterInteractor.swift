//
//  StoriesFilterInteractor.swift
//  LetsTell
//
//  Created by Павел Чернышев on 26.05.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol StoriesFilterBusinessLogic {
    func loadFilters(request: StoriesFilter.Filters.Request)
    func apply(request: StoriesFilter.Applying.Request)
}

protocol StoriesFilterDataStore {

}

class StoriesFilterInteractor: StoriesFilterBusinessLogic, StoriesFilterDataStore {
    var presenter: StoriesFilterPresentationLogic?
    var errorLogger: ErrorLogger?
    var requestFactory: RequestFactory
    var storeToken: TokenStorage
    var authController: AuthViewController
    var applyedFiltersStorage: ApplyedFiltersStorage
    var userStorage: OwnerStorage
    
    init(
        requestFactory: RequestFactory,
        storeToken: TokenStorage,
        authController: AuthViewController,
        filtersStorage: ApplyedFiltersStorage,
        userStorage: OwnerStorage
    ) {
        self.requestFactory = requestFactory
        self.storeToken = storeToken
        self.authController = authController
        self.applyedFiltersStorage = filtersStorage
        self.userStorage = userStorage
    }
    
    func loadFilters(request: StoriesFilter.Filters.Request) {
        guard let token = storeToken.getToken() else {
            authController.logout()
            return
        }
        requestFactory.setToken(token: token)
        
        let errorParser = ErrorParserState<ErrorList>()
        let lib = requestFactory.makeLibRequestFactory(errorParser: errorParser)
        
        let queue = DispatchQueue(label: "filters", qos: .userInitiated, attributes: .concurrent)
        let group = DispatchGroup()
        
        var lastError: NSError?
        var languagesSection = FilterSectionModel(id: .language, name: "Language".localized(), rows: [])
        
        queue.async(group: group) {
            let semaphore = DispatchSemaphore(value: 0)
            lib.languages { [self] response in
                switch response.result {
                case .success(let result):
                    var rows: [FilterModel] = []
                    for lang in result.body {
                        rows.append(FilterModel(id: lang.id, name: lang.name))
                    }
                    languagesSection.rows = rows
                    semaphore.signal()
                case .failure(let error):
                    let nsError = NSError(domain: "FilterInterpter_languages", code: NSError.ErrorCodes.filtersNetworkAFError.rawValue, userInfo: ["error": error.localizedDescription])
                    lastError = nsError
                    errorLogger?.log(nsError)
                    semaphore.signal()
                }
            }
            semaphore.wait()
        }
        
        var genresSection = FilterSectionModel(id: .ganre, name: "Genre".localized(), rows: [])
        
        queue.async(group: group) {
            let semaphore = DispatchSemaphore(value: 0)
            lib.genres { [self] response in
                switch response.result {
                case .success(let result):
                    var rows: [FilterModel] = []
                    for genre in result.body {
                        rows.append(FilterModel(id: genre.id, name: genre.name))
                    }
                    genresSection.rows = rows
                    semaphore.signal()
                case .failure(let error):
                    let nsError = NSError(domain: "FilterInterpter_genres", code: NSError.ErrorCodes.filtersNetworkAFError.rawValue, userInfo: ["error": error.localizedDescription])
                    lastError = nsError
                    errorLogger?.log(nsError)
                    semaphore.signal()
                }
            }
            semaphore.wait()
        }
        
        group.notify(queue: .global()) {
            guard lastError == nil else {
                guard let error = lastError else { fatalError("try to unwrap failed") }
                let response = StoriesFilter.Filters.Response(filters: NetworkResult.failure(error), applyedFilters: [])
                self.presenter?.presentFilters(response: response)
                return
            }
            var applyedFilters: [ApplyedFiltersStorageModel] = []
            if let user = self.userStorage.getOwner() {
                applyedFilters = self.applyedFiltersStorage.get(forUser: user.id)
            }
            let response = StoriesFilter.Filters.Response(filters: NetworkResult.success([languagesSection, genresSection]), applyedFilters: applyedFilters)
            self.presenter?.presentFilters(response: response)
        }
    }
    
    func apply(request: StoriesFilter.Applying.Request) {
        guard let user = userStorage.getOwner() else {
            presenter?.presentApplying(response: .init(filersChanged: false))
            return
        }
        
        let applyingFilters: [ApplyedFiltersStorageModel] = request.filters.reduce([]) { result, section in
            
            guard let activeRow = section.rows.first(where: { $0.active }) else {
                return result
            }
            
            var result = result
            result.append(ApplyedFiltersStorageModel(type: section.id, value: activeRow.id))
            
            return result
        }
        
        let applyingFiltersSet = Set<ApplyedFiltersStorageModel>(applyingFilters)
        let savedFiltersSet = Set<ApplyedFiltersStorageModel>(applyedFiltersStorage.get(forUser: user.id))
        
        if applyingFiltersSet == savedFiltersSet {
            presenter?.presentApplying(response: .init(filersChanged: false))
        } else {
            applyedFiltersStorage.save(forUser: user.id, filters: applyingFilters)
            presenter?.presentApplying(response: .init(filersChanged: true))
        }
    }
}
